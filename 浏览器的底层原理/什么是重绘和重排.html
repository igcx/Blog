<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>重绘和重排</title>
</head>
<body>


  <!-- 
    重绘和重排
      1. 重排: 对布局重新计算排布, 更新布局
         何时会触发重排: (布局发生改变)
            1、添加或者删除可见的DOM元素；
            2、元素位置改变；
            3、元素尺寸改变——边距、填充、边框、宽度和高度
            4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；
            5、页面渲染初始化；
            6、浏览器窗口尺寸改变——resize事件发生时；

      2. 重绘: 对界面, 进行渲染绘制
         何时触发重绘: 
           (1) 改变了不影响布局的样式(backgroundColor color), 只触发重绘
           (2) 改变布局了, 布局更新后, 也会触发重绘

    重绘和重排的关系:
      1. 重绘不一定会触发重排, 比如: 只改了背景色
      2. 只要重排了, 必然触发重绘!!!

    每个页面至少需要一次回流+重绘。(初始化渲染)
    重排和重绘的代价都很⾼昂，频繁重排重绘, 会破坏⽤户体验、让界面显示变迟缓。
    我们需要尽可能避免频繁触发重排和重绘, 尤其是重排会影响性能  

   -->

   <!-- 浏览器对重绘重排的优化 -->
   <script>
       let s = document.body.style
        s.padding = "2px" // 重排 + 重绘
        s.border = "1px solid red" // 再一次 重排 + 重绘
        s.color = "blue" // 再一次重绘
        s.backgroundColor = "#ccc" // 再一次 重绘
        s.fontSize = "14px" // 再一次 重排 + 重绘
        document.body.appendChild(document.createTextNode('abc!')) // 添加node，再一次 重排 + 重绘
        // 从上个实例代码中可以看到几行简单的JS代码就引起了 4次重排、6次重绘。
        // 而且我们也知道重排的花销也不小，如果每句JS操作都去重排重绘的话，浏览器可能就会受不了!
        // 所以浏览器会优化这些操作，浏览器会维护1个队列，把所有会引起重排、重绘的操作放入这个队列，
        // 等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个 批处理。
        // 这样就会让多次的重排、重绘变成了一次重排重绘。
        
        // 虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能起不到作用了。
   </script>
   
</body>
</html>